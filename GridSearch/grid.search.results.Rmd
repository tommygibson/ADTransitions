---
title: "Grid search optimization results"
output: pdf_document
header-includes: \usepackage{setspace}
---
\doublespacing 

```{r setup, echo = FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

# Grid search

The COBYLA algorithm, which we use for optimization of transition rate parameters $(\log(k_{0ij}), k_{1ij})$, is a local solver. This means that for any given set of initial values, the returned solution may only be locally optimal. In an effort to find the global optimum, we perform a grid search over different sets of initial values for $(\log(k_{0ij}), k_{1ij})$. The grid of values is comprised of pairwise combinations of equally spaced values $\log(k_{0ij}) = (-12, -10, -8, -6)$ and $k_{1ij} = (0.02, 0.04\overline{6}, 0.07\overline{3}, 0.10)$, for 16 possible sets of initial values. A given pair $(\log(k_0), k_1)$ is used as a set of initial values for all 12 transitions (24 parameters) in the optimization, i.e. the initial values for transitions $r_{12}, r_{16}, \dots, r_{94}$ are all the same for some pair $(\log(k_0), k_1)$ from the grid.

Five pairs of initial values are _invalid_, meaning at least one of the constraints on the parameter space is violated at the initial values and the algorithm will not start. Additionally, for three sets of initial values that are _initially_ valid, the algorithm ventures outside the constraint space within the first few iterations and does not return. We call these initial values invalid, and we ignore all invalid pairs of initial values. There are 8 valid pairs of initial values, which we let run to convergence.

We define convergence as a relative tolerance less than 0.005 for all parameters, where the relative tolerance between two values $x$ and $y$ is defined as 
\begin{align}
reltol(x, y) & = \vert x - y \vert / \mbox{min}(\vert x \vert, \vert y \vert).
\end{align}
For the algorithm to converge on iteration $m$, all 24 parameters $k$ must have $reltol(k^{(m)}, k^{(m - 1)}) < 0.005$.

# Results

## Optimal parameters

```{r}

library(knitr)
library(tidyverse)
library(ggplot2)
library(gghighlight)
library(grid)
library(gridExtra)
library(here)

source(here('BrookFuncs.R'))
source(here('AD_eval.f.g.R'))

opts.grid <- readRDS(here('GridSearch', 'opts.grid.rds'))

# p is number of initial values / optimizations
# k is number of parameters (12 * 2 = 24)

rij <- c("r12", "r16", "r18", "r23", "r29", "r34", "r63", "r67", "r74", "r87", "r89", "r94")
p <- length(opts.grid)
k <- length(opts.grid[[1]]$solution)

optvals <- vector(length = p)
iters <- vector(length = p)
params <- matrix(nrow = (k / 2 * p), ncol = 3)

for(i in 1:p){
  optvals[i] <- opts.grid[[i]]$objective
  iters[i] <- opts.grid[[i]]$iterations

  # stack parameter estimates into one matrix
  # there are p 12 x 2 matrices
  # 3rd column is index for which initial values were used
  params[(1 + (i - 1) * (k / 2)):(i * k / 2), ] <- cbind(matrix(opts.grid[[i]]$solution, ncol = 2, byrow = TRUE), i)
}

## which set of initial values produced the "optimal optimum"?

optimal <- as.numeric(optvals == min(optvals))
opt.index <- which(optimal == 1)

##### Optimal parameters

optparams <- matrix(params[, opt.index], ncol = 2, byrow = TRUE)
colnames(optparams) <- c("log(k0)", "k1")
rownames(optparams) <- rij

##### Data for all transitions














```
